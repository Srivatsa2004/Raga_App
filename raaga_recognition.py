# -*- coding: utf-8 -*-
"""Raaga recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HFtRjq7Jq_wDPOpJMxnX1Qv5_lWDOx8S
"""

!pip install --upgrade noisereduce
!pip uninstall numba -y
!pip install numba --force -reinstall
!pip install --upgrade librosa

import librosa
import numpy as np
import pandas as pd
import re
import matplotlib.pyplot as plt
import noisereduce as nr
import scipy.signal as signal
from collections import OrderedDict

"""ALmost correct code

more accurate frequency detection onset
"""

y ,sr= librosa.load("/content/Dhenuka.opus")
#applying noise cancellation

thresh=0.00
#y_clean= nr.reduce_noise(y, sr,prop_decrease=0.15)
y_clean = np.where(np.abs(y) < thresh, 0, y)
onset_detect= librosa.onset.onset_detect(y=y_clean,sr=sr)
onset_times= librosa.frames_to_time(onset_detect, sr=sr)

#plotting on graph
plt.figure(figsize=(40,4))
librosa.display.waveshow(y, sr=sr, alpha=0.4)

plt.vlines(onset_times, -1, 1, color='r', linestyle='--', label='Onsets')
plt.xlabel("Times")
plt.ylabel("Amplitude")
plt.title("Onset Detection in waveform")
plt.legend()
plt.show()

"""Detecting the onset frequencies and printing"""

n_fft = 2048  # Window size for the STFT
hop_length = 512  # Number of samples between successive frames
stft = librosa.stft(y, n_fft=n_fft, hop_length=hop_length)

# Get frequencies corresponding to STFT bins
frequencies = librosa.fft_frequencies(sr=sr, n_fft=n_fft)


# Get frequencies at onset times
onset_frequencies = []
for i in  onset_detect:
    # Get the magnitude spectrum for the current frame
    magnitude_spectrum = np.abs(stft[:,i])
    # Find the frequency bin with the maximum magnitude
    max_bin = np.argmax(magnitude_spectrum)


    # Get the frequency corresponding to the max bin
    onset_frequency = frequencies[max_bin]

    onset_frequencies.append(onset_frequency)


print("Filtered Onset Frequencies (Hz):", onset_frequencies)#

"""* **closest_frequency = min(shruthi_frequencies, key=lambda x: abs(frequency - x)):**
This line finds the frequency within shruthi_frequencies that is closest to the current frequency in onset_frequencies.
It uses the min function with a key argument that calculates the absolute difference between the frequency and each frequency in shruthi_frequencies. The frequency with the minimum absolute difference is considered the closest.
* In the above code **Lambda** is used to create an anonymous func without a name. It basically makes the code shorter and here it gives a comparison method for min(). It is telling the min() to find the frequency that has **smallest abs difference betweeen the target frequency**

* **if abs(frequency - closest_frequency) <= 5::**
Now, the comparison is made between the current frequency and the closest_frequency found in the previous step. If their absolute difference is within the tolerance (5 Hz), it's considered a match.
"""

shruthis={('C','Sa'): [261.63,523.25], ('C#','R1'): [277.18,554],
          ('D', 'R2/G1'): [293.66,587.33],  ('D#','R3/G2'): [311.13,622.25],
          ('E','G3'): [329.63,659.25], ('F',"M1"): [349.23,698],
          ('F#',"M2"): [369.99,739.99,1479], ('G',"P"): [392,783],
          ('G#',"D1"): [415.3,830.61,1661],('A',"D2/N1"): [440,880,1760],
          ('A#',"D3/N2"): [466.16,932.68,1864], ('B',"N3"): [246.94, 493.88, 987.77,1975.5]}


match_swara=[]
best_match_swara= None
for shruthi_name, shruthi_frequencies in shruthis.items():
    print(f"Checking for matches with {shruthi_name}:")
    for frequency in onset_frequencies:
        # Find closest shruthi frequency for the current frequency
        closest_shruthi_frequency = min(shruthi_frequencies, key=lambda x: abs(frequency - x))

        # Check if it's within the tolerance
        if abs(frequency - closest_shruthi_frequency) <= 6:
           best_match_swara = shruthi_name[1] if isinstance(shruthi_name, tuple) else shruthi_name
           match_swara.append(best_match_swara)
           print(f"  Frequency {frequency:.2f} Hz matches {shruthi_name[0]}")


    print("-" *10)  # Separator between dictionaries
print("Swaras associated are:",match_swara)



"""Trying to get input shruthi and match the swaras

* **with accuracy**
here we iterate through shruthi_names list then find
**swara_index = (i - start_index) % len(carnatic_swaras)** this ensures that shruthis index is mapped to 0 which is Sa in carnatic_swaras and other swaras are shifted accordingly.
**i-start_index**  calculates shift amount. i is the index of the current shruthi name.
* i is the current index in the loop of Shruthi names
* start_index is the index of the input shruthi to determine the shift
**%len(carnatic_swaras)** ensures that the result is always within the range of valid indices
"""

input_shruthi = input("Enter the shruthi:")

# Find the index of the input shruthi in the shruthi names
shruthi_names = [shruthi_name[0] for shruthi_name in shruthis.keys()]
try:
    start_index = shruthi_names.index(input_shruthi)
except ValueError:
    print(f"Shruthi '{input_shruthi}' not found in the dictionary.")
    exit()

# Create a new dictionary with shifted shruthi names
shifted_shruthis = {}
carnatic_swaras = ['S', 'R1', 'R2' or 'G1', 'R3' or' G2', 'G3', 'M1', 'M2', 'P', 'D1', 'D2' or 'N1', 'D3' or 'N2', 'N3']

# Directly map shruthi names to shifted Carnatic swaras
for i in range(len(shruthi_names)):
    # Calculate the index of the Carnatic swara based on the shift
    swara_index = (i - start_index) % len(carnatic_swaras)
    # Map the shruthi name to the shifted Carnatic swara
    shifted_shruthis[shruthi_names[i]] = carnatic_swaras[swara_index]



# Frequency matching and printing using shifted_shruthis
match_swara = []
swaras=[]
for shruthi_name, shruthi_frequencies in shruthis.items():  # Using original shruthis for frequencies
    print(f"Checking for matches with {shruthi_name}:")
    for frequency in onset_frequencies:
        closest_shruthi_frequency = min(shruthi_frequencies, key=lambda x: abs(frequency - x))
        if abs(frequency - closest_shruthi_frequency) <= 6:
            # Get the shifted Carnatic swara from shifted_shruthis
            shifted_swara = shifted_shruthis[shruthi_name[0]]
            match_swara.append(shifted_swara)
            swaras.append(shifted_swara)
            print(f"  Frequency {frequency:.2f} Hz matches {shruthi_name[0]} ({shifted_swara})")

    print("-" * 10)
# Replace 'R2' with 'G1' in shifted_swaras
# # Replace 'R3' with 'G2' in shifted_swaras
'''
if 'R1' in swaras:
  swaras= ['G1' if swara == 'R2' else swara for swara in swaras]
elif 'R2' in swaras:
  swaras= ['G2' if swara == 'R3' else swara for swara in swaras]
'''
swara_map = OrderedDict([("R1", "R1"), ("R2", "G1"), ("R3", "G2"),("G1", "G1"),
 ("G2", "G2"),("G3", "G3"),("Sa", "S"), ("Ma1","M1"),("Ma2","M2"), ("Pa","P"),
  ("Da1", "D1"), ("Da2", "N1"),("Da3","N2"),("N1","N1"),("N2","N2"),
   ("Ni3","N3"),("D3","N2")])
swaras_replace =[]
#checking for R1
for swara in swaras:
  if 'R1' in swaras:
    swara_in_mapping = next((k for k in swara_map if swara.startswith(k)), swara)
    swaras_replace.append(swara_map.get(swara_in_mapping, swara))
  elif 'R2' in swaras and swara =="R3":
    swaras_replace.append('G2')
  # checking for Da1
  elif 'D1' in swaras and swara =="D2":
    swaras_replace.append('N1')
  elif 'D2' in swaras and swara =="D3":
    swaras_replace.append('N2')

  else:
    swaras_replace.append(swara)


swaras=swaras_replace



desired_order = ['S','R', 'G', 'M', 'P', 'D', 'N']

ordered_swaras = []
# returns only once each swara
'''for desired_swara in desired_order:
    for swara in swaras:
        if desired_swara in swara and swara not in ordered_swaras:
            ordered_swaras.append(swara)
            break  # Move to the next desired_swara after finding one match
print("Shifted swaras are:",swaras)
print("Ordered Swaras:", ordered_swaras)'''

for desired_swara in desired_order:
    matching_swaras = [swara for swara in swaras if desired_swara in swara and swara not in ordered_swaras]
    ordered_swaras.extend(matching_swaras)
unique_swaras = list(OrderedDict.fromkeys(ordered_swaras))
print("Shifted swaras are:",swaras)
print("Ordered swaras", unique_swaras)
#print("Ordered Swaras:", ordered_swaras)

"""uploading raga dataset"""

df = pd.read_csv("/content/Shruthi & Ragas - Raagas with names.csv")

for index, value in df['Swaras'].items():

# Create a set of ordered_swaras for faster lookup
  ordered_swaras_set = set(ordered_swaras)

for index, value in df['Swaras'].items():
    # Extract all Swaras from the cell value using regex
    cell_swaras = re.findall(r"[SRGMPDN][123]?[/]?[SRGMPDN]?[123]?", value)
    cell_swaras_set = set(cell_swaras)  # Create a set for efficient comparison

    # Check if all swaras in ordered_swaras are present in cell_swaras and
    # if cell_swaras contains only swaras from ordered_swaras
    if ordered_swaras_set.issubset(cell_swaras_set):
        #print(f"Raaga: {df.loc[index, 'Raagas']} contains the swaras {', '.join(ordered_swaras)}")

    # Additional condition to print raagas with only the swaras of ordered_swaras
      if cell_swaras_set == ordered_swaras_set:
        print(f"Raaga: {df.loc[index, 'Raagas']}  {', '.join(unique_swaras)}")

